<h1 id="compile-options">Compile options</h1>
<p>Your Fortran compiler is your friend and has a lot of useful command
line options. Unfortunately, they are vendor specific, so you have to
check the documentation of the compiler you are using. Here you will
find some useful options for GCC’s gfortran and Intel’s ifort compilers.
The options are organized by category, e.g., debugging, performance and
so on.</p>
<p>Many compiler flags are actually handled by CMake, so that you don’t
have to set those explicitly.</p>
<h2 id="debugging">Debugging</h2>
<p>The most important flag for debugging is <code>-g</code>, which will
be set automatically when <code>CMAKE_BUILD_TYPE</code> is
<code>Debug</code> or <code>RelWithDebInfo</code>. It ensures that
source information is added to the executable or library.</p>
<p>For compilers that optimize by default, you would also set
<code>-O0</code>, i.e., no optimization because that tends to complicate
debugging since the compiler may remove or replace some statements. For
GCC this is not required, but it may be for Intel’s ifort.</p>
<p>Note that the <code>-g</code> flag by itself has no influence on the
performance of your executable, although it increases the file size.
This makes the flag also useful in the context of profiling.</p>
<p>The compiler can also generate extra warnings, and it is good
practice to let it do so. Be sure to eliminate warnings by improving
your code. Almost all warnings should be heeded, unless you are really
sure what you are doing</p>
<p>Every compiler allows very detailed control over the warnings it
generates, and it is possible to switch on an off specific warnings on a
case by case basis.</p>
<p>In general, it is good practice to switch on a wide range of warnings
which is easy with most compilers.</p>
<h3 id="gcc">GCC</h3>
<p>For GCC, <code>-Wall</code> and <code>-Wextra</code> are quite
useful. They will warn about a wide range of potential issues such as
using variables that might not have been initialized, testing floating
point values for equality, variables that are declared but not used and
so on.</p>
<p>For even more warnings, add <code>-pedantic</code>.</p>
<p>Detailed information on the warnings generated by these families of
options can be found in the compiler’s documentation.</p>
<p>You can have the compiler insert code to check that you don’t try to
access arrays using indices that are out of bounds by using the
<code>-fbounds-check</code>. However, keep in mind that this will
decrease the performance slightly since the code to check the bounds has
to be executed, so do not use this flag for a build that you intend for
production or release.</p>
<h3 id="intel">Intel</h3>
<p>For ifort, the relevant option is <code>-warn all</code>, and
<code>-diag-enable remark</code> will turn on many warnings.</p>
<p>You can have the compiler insert code to check that you don’t try to
access arrays using indices that are out of bounds by using the
<code>-check bounds</code>. However, keep in mind that this will
decrease the performance slightly since the code to check the bounds has
to be executed, so do not use this flag for a build that you intend for
production or release.</p>
<p>The Intel compiler can check explicitly at runtime for the use of
uninitialized variables if you use the <code>-check uninit</code>
flag.</p>
<p>By default, the Intel compilers support quite some extensions to
Fortran for historical reasons. If you want it to be strict about a
standard, you can force that using the <code>-stand &lt;spec&gt;</code>
flag, where <code>&lt;spec&gt;</code> is any of <code>f77</code>,
<code>f90</code>, <code>f95</code>, <code>f03</code>, <code>f08</code>,
<code>f18</code>.</p>
<h2 id="profiling">Profiling</h2>
<p>If you want to improve the performance of your code, it is good
practice to measure the time spent in procedures, so that you know which
ones to concentrate your efforts on. It doesn’t make much sense to try
and improve the performance of a procedure that takes only 1 % of the
total run time.</p>
<p>There are many tools to measure the performance of your code, some
open source, some commercial. A very simple one is <code>gprof</code>
and this is supported by GCC.</p>
<p>The <code>-pg</code> flag for both compiling and linking will
instrument your application to generate statistics of the time spent in
functions, the number of function calls and so on. Once the application,
e.g., <code>my_applexe</code> has run, you can display the performance
statistics using:</p>
<pre class="bash"><code class="language-fortran">$ gprof my_applexe</code></pre>
<h2 id="optimization">Optimization</h2>
<p>Compilers can be used with various levels of optimization controlled
via command line options * <code>-O0</code>: no optimization, *
<code>-Os</code>: minimize the size of the executable, *
<code>-O1</code> to <code>-O3</code>: apply increasing levels of
optimization.</p>
<p>Note that the level of optimization may impact the results. At
<code>-O3</code>, (GCC) the compiler can reorder numerical expressions,
so you may get different results. For Intel compilers, this happens even
at <code>-O2</code>.</p>
<p>It may help to let the compiler generate machine code specific for
the hardware you are running on. When you use <code>march=native</code>
the instruction set most suited for the hardware you are building your
application on will be used, in general resulting in the best
performance.</p>
